#!/usr/bin/env python
# coding: utf-8

# # 题目
# 
# ### 0,1，……，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字.例如，0、1、2、3、4、5这5个数字组成一个圆圈（如图6.3所示），从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3
# ![6_3](6_3.png)

# In[ ]:


'''
思路：

本题就是有名的约瑟夫环问题。这个题目有两种解题方法
'''
'''
1.用环形链表模拟圆圈

既然题目中有一个数字圆圈，很自然的想法就是用一个数据结构来模拟这个圆圈。在常用的数据结构中，我们很容易想到环形链表。我们可以创建一个共有n个节点的环形链表，然后每次在这个链表中删除第m个节点
'''
def LastRemaining(n,m):
    if n<1 or m<1:
        return -1
    i=0
    numbers=range(n)
    current=0
    while numbers:
        for i in range(1,m):
            current+=1
            if current=len(numbers)-1:
                current=0
        next=current+1
        if next=len(numbers)-1:
            next=0
        current-=1
        numbers.pop(current)
        current=next
    return numbers[current]


# In[ ]:


'''
2.分析被删除的数字的规律并直接计算出圆圈中最后剩下的数字

首先我们定义一个关于n和m的方程f(n,m)，表示每次在n个数字0,1，……，n-1中删除第m个数字最后剩下的数字。
在这n个数字中，第一个被删除的数字是(m-1)%n。为了简单起见，我们把(m-1)%n记为k，那么删除k个之后剩下的n-1个数字为0,1，……，k-1,k+1,……,n-1，并且下一次删除从数字k+1开始计数。相当于在剩下的序列中,k+1排在最前面，从而形成k+1,...,n-1,0,1,...,k-1。该序列最后剩下的数字也应该是关于n和m的函数。由于这个序列的规律和最初的序列不一样（最初的序列是从0开始的连续序列），因此该函数不同于前面的函数，记为f'(n-1,m)。最初序列最后剩下的数字f(n,m)一定是删除一个数字之后的序列最后剩下的数字，即f(n,m)=f'(n-1,m)。
接下来我们把剩下的这n-1个数字的序列k+1,...,0,1,...,k-1进行映射，映射的结果是形成一个0~n-2的序列。
k+1 -> 0
k+2 -> 1
...
n-1 -> n-k-2
0  ->  n-k-1
1  ->  n-k
...
k-1 -> n-2
我们把映射定义为p,则p(x)=(x-k-1)%n。他表示如果映射前的数字是x，那么映射后的数字是(x-k-1)%n。该映射的逆映射是p-1(x)=(x+k+1)%n。
由于映射之后的序列和最初的序列具有同样的形式，即都是从0开始的连续序列，因此仍然可以用函数f来表示，记为f(n-1,m)。根据我们的映射规则，映射之前的序列中最后剩下的数字f'(n-1,m)=p-1[f(n-1,m)]=[f(n-1,m)+k+1]%n，把k=(m-1)%n代入得到f(n,m)=f'(n-1,m)=[f(n-1,m)+m]%n。
经过上面复杂的分析，我们终于找到了一个递归公式。要得到n个数字的序列中最后剩下的数字，只需要得到N-1个数字的序列中最后剩下的数字，并以此类推。当n=1时，也就是序列中开始只有一个数字0，那么很显然最后剩下的数字就是0。我们把这种关系表示为如下的公式
'''


# $$
# f(n,m)=\left\{\begin{matrix}
# 0 & n=1 \\ 
# [f(n-1,m)+m]\%n & n>1 
# \end{matrix}\right.
# $$

# In[ ]:


'''
具体的代码
'''
def LastRemaining(n,m):
    if n<1 or m<1:
        return -1
    last=0
    for i in range(2,n+1):
        last=(last+m)%i
    return last

