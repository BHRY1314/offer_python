#!/usr/bin/env python
# coding: utf-8

# # 题目
# 
# ### 写一个函数，求两个整数之和，要求在函数体内不得使用“+”，“-”，“x”，“÷”四则运算符

# In[ ]:


'''
思路：

首先我们可以分析人们是如何做十进制加法的，比如是如何得出5+17=22这个结果的。实际上，我们可以分成三步进行：第一步只做各位相加不进位，此时相加的结果是12（个位数5和7相加不要进位是2，十位数0和1相加的结果是1）；第二步做进位，5+7有进位，进位的值是10；第三步把前面两个结果加起来，12+10的结果是22，刚好5+17=22.
我们一直在想，求两数之和四则运算都不能用，那还能用什么?对数字做运算，除了四则运算外，也就剩下位运算了。以二进制再来分析一下前面的“三步走”策略对二进制是不是也适用。
5的二级制是101,17的二进制是10001。我们还是试着把计算分成三步：第一步各位相加但不计进位，得到的结果是10100（最后一位两个数都是1，相加的结果是二进制的10，这一步不计进位，因此结果仍然是0）；第二步记下进位，在这个例子中只在最后一位相加时产生一个进位，结果是二进制的10；第三步把前两步的结果相加，得到的结果是10110，转换成十进制正好是22，由此可见“三步走”策略对二进制也是适用的。
接下来我们试着把二进制的加法用位运算来替代。第一步不考虑进位对每一位相加。0加0、1加1的结果都是0,0加1、1加0的结果都是1.我们注意到，这和异或的结果是一样的。对异或而言，0和0、1和1的异或结果是0，而0和1、1和0的异或结果是1.接着考虑第二步进位，对0加0、1加0而言，都不会产生进位，只有1加1时，会向前产生一个进位。此时我们可以想象两个数先做位与运算，然后再向左移动一位。只有两个数都是1的时候，位与得到的结果是1，其余都是0.第三步把前面两个步骤的结果相加。第三步相加的过程依然是重复前面两步，知道不产生进位为止。
'''

##由于python没有无符号右移操作，所以需要越界检查
def Add(num1,num2):
    while num2!=0:
        sum_num=(num1^num2)& 0xffffffff
        carry=((num1&num2)<<1)& 0xffffffff
        num1=sum_num
        num2=carry
    if num1 <= 0x7fffffff:
        result = num1
    else:
        result = ~(num1^0xffffffff)
    return result

